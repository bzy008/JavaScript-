<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	方式1：Object构造函数模式
	套路：先创建空Object对象，在动态添加属性、方法
	适用场景：起始时不确定对象内部数据
	问题：语句太多
	<script type="text/javascript">
		var p = new Object()
		p.name = 'tom'
		p.age = 12
		p.setName = function (name) {
			this.name = name
		}
		//测试
		p.setName('jack')
		console.log(p.name, p.age)
	</script>


	方式2：对象字面量模式
	套路：使用{}创建对象，同时指定属性、方法
	适用场景：起始时对象内部数据是确定的
	问题：如果创建多个对象，有重复代码
	<script type="text/javascript">
		var p = {
			name: 'tom',
			age: 12,
			setName: function (name) {
				this.name = name
			}
		}
		//测试
		p.setName('jack')
		console.log(p.name, p.age)
	</script>


	方式3：工厂模式(不常用)
	套路：通过工厂函数动态创建对象并返回
	适用场景：需要创建多个对象
	问题：对象没有一个具体的类型，都是Object类型
	<script type="text/javascript">
		function createPerson(name, age) {
			var obj = {
				name: name,
				age: age,
				setName: function (name) {
					this.name = name
				}
			}
			return obj
		}
		//测试
		var p1 = createPerson('tom', 12)
		var p2 = createPerson('bob', 12)
		console.log(p1, p2)
	</script>


	方式4：自定义构造函数模式
	套路：自定义构造函数，通过new创建对象
	适用场景：需要创建多个类型确定的对象
	问题：每个对象都有相同的数据，浪费内存

	<script type="text/javascript">
		function Person(name, age) {
			this.name = name
			this.age = age
			this.setName = function(name) {
				this.name = name
			}
		}
		var p = new Person('tom', 12)
		p.setName('jack')
		console.log(p.name, p.age)
	</script>

	方式6：构造函数+原型的组合
	套路：自定义构造函数，属性在函数中初始化，方法添加到原型上
	适用场景： 需要创建多个类型确定的对象
	<script type="text/javascript">
		function Person(name, age) {
			this.name = name
			this.age = age
		}
		Person.prototype.setName = function(name) {
			this.name = name
		}
		var p1 = new Person('tom', 23)
		var p2 = new Person('jack', 24)
		console.log(p1, p2)
	</script>
</body>
</html>